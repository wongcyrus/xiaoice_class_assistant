#!/usr/bin/env python3
"""
Pre-generate presentation_messages from PPTX speaker notes and cache them
for fast retrieval by generate_presentation_message().

This tool:
1. Reads speaker notes from each slide
2. Uses Gemini to generate a message for each slide
3. Caches each message by speaker notes content (not slide number)
4. Pre-generates speech files and uploads to GCS bucket

Usage:
  python preload_presentation_messages.py \
    --pptx /path/to/deck.pptx \
    --languages en,zh

Notes:
  - Generates ONE message per unique speaker notes content
  - Cache key format: "v1:{language}:{hash(speaker_notes)}"
  - No slide numbers in cache - works even if slides reordered
  - VBA sends current slide's speaker notes for cache lookup
  - Duplicate speaker notes (same content) share same cache entry
  - Speech files named: speech_{lang}_{content_hash}.mp3
  - Bucket name read from config.py (generated from Terraform outputs)
"""

import argparse
import logging
import os
import sys
import time
import json
import requests
from pptx import Presentation

# Import config for bucket name
try:
    import config
except ImportError:
    config = None

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s:%(name)s:%(message)s',
    stream=sys.stdout
)
logger = logging.getLogger(__name__)




def parse_languages(s: str) -> List[str]:
    return [x.strip() for x in s.split(",") if x.strip()]





def get_speaker_notes(prs: Presentation, slide_index: int) -> str:
    """Extract speaker notes from a slide.
    
    Args:
        prs: PowerPoint presentation object
        slide_index: 1-based slide index
        
    Returns:
        Speaker notes text, or empty string if no notes
    """
    if slide_index < 1 or slide_index > len(prs.slides):
        raise IndexError(
            f"slide index {slide_index} out of range (1..{len(prs.slides)})"
        )
    slide = prs.slides[slide_index - 1]
    
    # Access speaker notes
    if not slide.has_notes_slide:
        return ""
    
    notes_slide = slide.notes_slide
    if not notes_slide or not notes_slide.notes_text_frame:
        return ""
    
    return (notes_slide.notes_text_frame.text or "").strip()








def load_cdktf_outputs():
    """
    Loads backend/cdktf_outputs.json to get infrastructure details.
    """
    # Try to find the file relative to this script
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # backend/admin_tools/../../cdktf_outputs.json -> backend/cdktf_outputs.json
    output_path = os.path.join(os.path.dirname(script_dir), "cdktf_outputs.json")
    
    if not os.path.exists(output_path):
        return {}
        
    try:
        with open(output_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        logger.warning(f"Failed to read cdktf_outputs.json: {e}")
        return {}


def load_api_key():
    """
    Attempts to load the API key from backend/admin_tools/api_key.json.
    Returns the key string or None if not found/valid.
    """
    key_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "api_key.json"
    )
    
    if not os.path.exists(key_path):
        return None
        
    try:
        with open(key_path, 'r') as f:
            data = json.load(f)
            # Support the format generated by create_api_key.py or simple {"api_key": "..."}
            return data.get("key_string") or data.get("api_key")
    except Exception as e:
        logger.warning(f"Failed to read api_key.json: {e}")
        return None


def main():
    parser = argparse.ArgumentParser(
        description="Preload presentation message cache from PPTX "
                    "speaker notes"
    )
    parser.add_argument("--pptx", required=True, help="Path to PPTX file")
    parser.add_argument("--api-url", help="Base URL of the Config Cloud Function")
    parser.add_argument("--api-key", help="API Key for the gateway")
    parser.add_argument(
        "--course-id", help="Optional Course ID for config and cache tagging"
    )

    args = parser.parse_args()

    # Resolve defaults
    file_api_key = load_api_key()
    final_api_key = args.api_key or file_api_key
    
    final_api_url = args.api_url
    
    if not final_api_url:
        # Try to load from cdktf_outputs.json
        outputs = load_cdktf_outputs()
        
        # Check if outputs are nested under "cdktf" or similar
        if "api-url" not in outputs:
            for val in outputs.values():
                if isinstance(val, dict) and "api-url" in val:
                    outputs = val
                    break
        
        base_url = outputs.get("api-url")
        if base_url:
            # Remove trailing slash
            if base_url.endswith("/"):
                base_url = base_url[:-1]
            
            # Construct full config endpoint
            final_api_url = f"https://{base_url}/api/config"
    
    if not final_api_url:
        logger.error("❌ API URL is required. Provide --api-url or ensure backend/cdktf_outputs.json exists and has 'api-url'.")
        sys.exit(1)
        
    if not final_api_key:
        logger.warning("⚠️ No API Key provided or found. Request may fail if Gateway is secured.")

    if not os.path.exists(args.pptx):
        raise FileNotFoundError(args.pptx)
    
    ppt_filename = os.path.basename(args.pptx)

    prs = Presentation(args.pptx)
    total_slides = len(prs.slides)
    
    print(f"\nProcessing {total_slides} slides from {args.pptx}")
    print(f"Target API: {final_api_url}")
    print("Using API to generate messages...\n")

    # Append API key to URL if provided
    url = final_api_url
    if final_api_key:
        if "?" in url:
            url += f"&key={final_api_key}"
        else:
            url += f"?key={final_api_key}"

    for slide_idx in range(1, total_slides + 1):
        speaker_notes = get_speaker_notes(prs, slide_idx)
        
        if not speaker_notes:
            print(f"Slide {slide_idx}: No speaker notes - skipping")
            continue
        
        logger.info(f"\n--- Processing {ppt_filename}, Slide {slide_idx} ---")
        logger.info(f"Notes: {speaker_notes[:60]}...")
        
        payload = {
            "generate_presentation": True,
            "courseId": args.course_id,  # Use course_id if provided
            "context": speaker_notes,
            "ppt_filename": ppt_filename,
            "page_number": str(slide_idx) # Ensure it's a string like VBA client
        }
        
        try:
            start_time = time.time()
            response = requests.post(url, json=payload)
            duration = time.time() - start_time
            
            if response.status_code == 200:
                logger.info(f"✅ API Success ({duration:.2f}s)")
            else:
                logger.error(f"❌ API Error {response.status_code}: {response.text}")
        except Exception as e:
            logger.error(f"❌ Request Failed: {e}")
            
        # Wait a bit between slides to simulate real pacing
        logger.info("Waiting 2 seconds before next slide...")
        time.sleep(2)

    logger.info(f"\n✅ Preloading complete for {args.pptx}!")
